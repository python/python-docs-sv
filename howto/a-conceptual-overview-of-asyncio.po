# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001 Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Daniel Nylander <po@danielnylander.se>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.14\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-21 14:19+0000\n"
"PO-Revision-Date: 2025-08-15 14:19+0000\n"
"Last-Translator: Daniel Nylander <po@danielnylander.se>, 2025\n"
"Language-Team: Swedish (https://app.transifex.com/python-doc/teams/5390/"
"sv/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: sv\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

msgid "A Conceptual Overview of :mod:`!asyncio`"
msgstr "En konceptuell översikt av :mod:`!asyncio`"

msgid ""
"This :ref:`HOWTO <how-tos>` article seeks to help you build a sturdy mental "
"model of how :mod:`asyncio` fundamentally works, helping you understand the "
"how and why behind the recommended patterns."
msgstr ""
"Den här artikeln :ref:`HOWTO <how-tos>` syftar till att hjälpa dig att bygga "
"en stabil mental modell av hur :mod:`asyncio` i grunden fungerar, och "
"hjälper dig att förstå hur och varför bakom de rekommenderade mönstren."

msgid ""
"You might be curious about some key :mod:`!asyncio` concepts. You'll be "
"comfortably able to answer these questions by the end of this article:"
msgstr ""
"Du kanske är nyfiken på några viktiga :mod:`!asyncio`-koncept. Du kommer att "
"kunna svara på dessa frågor i slutet av den här artikeln:"

msgid "What's happening behind the scenes when an object is awaited?"
msgstr "Vad händer bakom kulisserna när ett objekt är väntat?"

msgid ""
"How does :mod:`!asyncio` differentiate between a task which doesn't need CPU-"
"time (such as a network request or file read) as opposed to a task that does "
"(such as computing n-factorial)?"
msgstr ""
"Hur skiljer :mod:`!asyncio` mellan en uppgift som inte behöver CPU-tid (t."
"ex. en nätverksförfrågan eller filläsning) och en uppgift som behöver CPU-"
"tid (t.ex. beräkning av n-faktoriell)?"

msgid ""
"How to write an asynchronous variant of an operation, such as an async sleep "
"or database request."
msgstr ""
"Hur man skriver en asynkron variant av en operation, t.ex. en asynkron sömn "
"eller databasförfrågan."

msgid ""
"The `guide <https://github.com/anordin95/a-conceptual-overview-of-asyncio/ "
"tree/main>`_ that inspired this HOWTO article, by Alexander Nordin."
msgstr ""
"Guiden <https://github.com/anordin95/a-conceptual-overview-of-asyncio/ tree/"
"main>`_ som inspirerade till den här HOWTO-artikeln, av Alexander Nordin."

msgid ""
"This in-depth `YouTube tutorial series <https://www.youtube.com/ watch?"
"v=Xbl7XjFYsN4&list=PLhNSoGM2ik6SIkVGXWBwerucXjgP1rHmB>`_ on ``asyncio`` "
"created by Python core team member, Łukasz Langa."
msgstr ""
"Denna djupgående `YouTube tutorial-serie <https://www.youtube.com/ watch?"
"v=Xbl7XjFYsN4&list=PLhNSoGM2ik6SIkVGXWBwerucXjgP1rHmB>`_ om ``asyncio`` "
"skapad av Python core team-medlem, Łukasz Langa."

msgid ""
"`500 Lines or Less: A Web Crawler With asyncio Coroutines <https:// aosabook."
"org/en/500L/a-web-crawler-with-asyncio-coroutines.html>`_ by A. Jesse Jiryu "
"Davis and Guido van Rossum."
msgstr ""
"`500 rader eller mindre: A Web Crawler With asyncio Coroutines <https:// "
"aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html>`_ av A. "
"Jesse Jiryu Davis och Guido van Rossum."

msgid "A conceptual overview part 1: the high-level"
msgstr "En konceptuell översikt del 1: den höga nivån"

msgid ""
"In part 1, we'll cover the main, high-level building blocks of :mod:`!"
"asyncio`: the event loop, coroutine functions, coroutine objects, tasks and "
"``await``."
msgstr ""
"I del 1 går vi igenom de viktigaste byggstenarna på hög nivå i :mod:`!"
"asyncio`: händelseslingan, coroutine-funktioner, coroutine-objekt, tasks och "
"``await``."

msgid "Event Loop"
msgstr "Händelseslinga"

msgid ""
"Everything in :mod:`!asyncio` happens relative to the event loop. It's the "
"star of the show. It's like an orchestra conductor. It's behind the scenes "
"managing resources. Some power is explicitly granted to it, but a lot of its "
"ability to get things done comes from the respect and cooperation of its "
"worker bees."
msgstr ""
"Allt i :mod:`!asyncio` sker i förhållande till händelseslingan. Den är "
"stjärnan i showen. Den är som en orkesterdirigent. Den är bakom kulisserna "
"och hanterar resurser. Viss makt ges uttryckligen till den, men mycket av "
"dess förmåga att få saker gjorda kommer från respekt och samarbete från dess "
"arbetsbin."

msgid ""
"In more technical terms, the event loop contains a collection of jobs to be "
"run. Some jobs are added directly by you, and some indirectly by :mod:`!"
"asyncio`. The event loop takes a job from its backlog of work and invokes it "
"(or \"gives it control\"), similar to calling a function, and then that job "
"runs. Once it pauses or completes, it returns control to the event loop. The "
"event loop will then select another job from its pool and invoke it. You can "
"*roughly* think of the collection of jobs as a queue: jobs are added and "
"then processed one at a time, generally (but not always) in order. This "
"process repeats indefinitely with the event loop cycling endlessly onwards. "
"If there are no more jobs pending execution, the event loop is smart enough "
"to rest and avoid needlessly wasting CPU cycles, and will come back when "
"there's more work to be done."
msgstr ""
"I mer tekniska termer innehåller händelseslingan en samling jobb som ska "
"köras. Vissa jobb läggs till direkt av dig och andra indirekt av :mod:`!"
"asyncio`. Händelseslingan tar ett jobb från sin backlog av arbete och "
"anropar det (eller \"ger det kontroll\"), liknande att anropa en funktion, "
"och sedan körs det jobbet. När det pausas eller slutförs återgår kontrollen "
"till händelseslingan. Händelseslingan väljer sedan ett annat jobb från sin "
"pool och anropar det. Du kan *genomgående* tänka på samlingen av jobb som en "
"kö: jobb läggs till och bearbetas sedan ett i taget, i allmänhet (men inte "
"alltid) i ordning. Denna process upprepas på obestämd tid och "
"händelseslingan fortsätter i all oändlighet. Om det inte finns fler jobb som "
"väntar på att utföras är händelseslingan tillräckligt smart för att vila och "
"undvika att slösa CPU-cykler i onödan, och kommer tillbaka när det finns mer "
"arbete att göra."

msgid ""
"Effective execution relies on jobs sharing well and cooperating; a greedy "
"job could hog control and leave the other jobs to starve, rendering the "
"overall event loop approach rather useless."
msgstr ""
"Ett effektivt utförande bygger på att jobben delar med sig väl och "
"samarbetar; ett girigt jobb kan ta kontrollen och låta de andra jobben "
"svälta, vilket gör den övergripande händelseslingan ganska värdelös."

msgid ""
"import asyncio\n"
"\n"
"# This creates an event loop and indefinitely cycles through\n"
"# its collection of jobs.\n"
"event_loop = asyncio.new_event_loop()\n"
"event_loop.run_forever()"
msgstr ""
"import asyncio\n"
"\n"
"# This creates an event loop and indefinitely cycles through\n"
"# its collection of jobs.\n"
"event_loop = asyncio.new_event_loop()\n"
"event_loop.run_forever()"

msgid "Asynchronous functions and coroutines"
msgstr "Asynkrona funktioner och coroutines"

msgid "This is a basic, boring Python function::"
msgstr "Detta är en grundläggande, tråkig Python-funktion::"

msgid ""
"def hello_printer():\n"
"    print(\n"
"        \"Hi, I am a lowly, simple printer, though I have all I \"\n"
"        \"need in life -- \\nfresh paper and my dearly beloved octopus \"\n"
"        \"partner in crime.\"\n"
"    )"
msgstr ""
"def hello_printer():\n"
"    print(\n"
"        \"Hi, I am a lowly, simple printer, though I have all I \"\n"
"        \"need in life -- \\nfresh paper and my dearly beloved octopus \"\n"
"        \"partner in crime.\"\n"
"    )"

msgid "Calling a regular function invokes its logic or body::"
msgstr "När du anropar en vanlig funktion anropas dess logik eller kropp::"

msgid ""
">>> hello_printer()\n"
"Hi, I am a lowly, simple printer, though I have all I need in life --\n"
"fresh paper and my dearly beloved octopus partner in crime."
msgstr ""
">>> hello_printer()\n"
"Hej, jag är en liten, enkel skrivare, även om jag har allt jag behöver i "
"livet -\n"
"färskt papper och min kära älskade bläckfisk som medbrottsling."

msgid ""
"The :ref:`async def <async def>`, as opposed to just a plain ``def``, makes "
"this an asynchronous function (or \"coroutine function\"). Calling it "
"creates and returns a :ref:`coroutine <coroutine>` object."
msgstr ""
":ref:`async def <async def>`, i motsats till bara en vanlig ``def``, gör "
"detta till en asynkron funktion (eller \"coroutine-funktion\"). När den "
"anropas skapas och returneras ett :ref:`coroutine <coroutine>`\\ -objekt."

msgid ""
"async def loudmouth_penguin(magic_number: int):\n"
"    print(\n"
"     \"I am a super special talking penguin. Far cooler than that printer. "
"\"\n"
"     f\"By the way, my lucky number is: {magic_number}.\"\n"
"    )"
msgstr ""
"async def loudmouth_penguin(magic_number: int):\n"
"    print(\n"
"     \"I am a super special talking penguin. Far cooler than that printer. "
"\"\n"
"     f\"By the way, my lucky number is: {magic_number}.\"\n"
"    )"

msgid ""
"Calling the async function, ``loudmouth_penguin``, does not execute the "
"print statement; instead, it creates a coroutine object::"
msgstr ""
"När async-funktionen ``loudmouth_penguin`` anropas utförs inte "
"utskriftssatsen, utan i stället skapas ett coroutine-objekt::"

msgid ""
">>> loudmouth_penguin(magic_number=3)\n"
"<coroutine object loudmouth_penguin at 0x104ed2740>"
msgstr ""
">>> loudmouth_penguin(magic_number=3)\n"
"<coroutine object loudmouth_penguin at 0x104ed2740>"

msgid ""
"The terms \"coroutine function\" and \"coroutine object\" are often "
"conflated as coroutine. That can be confusing! In this article, coroutine "
"specifically refers to a coroutine object, or more precisely, an instance "
"of :data:`types.CoroutineType` (native coroutine). Note that coroutines can "
"also exist as instances of :class:`collections.abc.Coroutine` -- a "
"distinction that matters for type checking."
msgstr ""
"Termerna \"coroutine-funktion\" och \"coroutine-objekt\" sammanfattas ofta "
"som coroutine. Det kan vara förvirrande! I den här artikeln hänvisar "
"coroutine specifikt till ett coroutine-objekt, eller mer exakt, en instans "
"av :data:`types.CoroutineType` (native coroutine). Observera att coroutines "
"också kan existera som instanser av :class:`collections.abc.Coroutine` -- en "
"distinktion som är viktig för typkontroll."

msgid ""
"A coroutine represents the function's body or logic. A coroutine has to be "
"explicitly started; again, merely creating the coroutine does not start it. "
"Notably, the coroutine can be paused and resumed at various points within "
"the function's body. That pausing and resuming ability is what allows for "
"asynchronous behavior!"
msgstr ""
"En coroutine representerar funktionens kropp eller logik. En coroutine måste "
"startas explicit; det räcker inte med att skapa en coroutine för att starta "
"den. Coroutinen kan pausas och återupptas vid olika punkter inom funktionens "
"kropp. Denna förmåga att pausa och återuppta är det som möjliggör asynkront "
"beteende!"

msgid ""
"Coroutines and coroutine functions were built by leveraging the "
"functionality of :term:`generators <generator iterator>` and :term:"
"`generator functions <generator>`. Recall, a generator function is a "
"function that :keyword:`yield`\\s, like this one::"
msgstr ""
"Coroutines och coroutine-funktioner byggdes genom att utnyttja "
"funktionaliteten i :term:`generators <generator iterator>` och :term:"
"`generator functions <generator>`. Kom ihåg att en generatorfunktion är en "
"funktion som :keyword:`yield`\\s, som den här::"

msgid ""
"def get_random_number():\n"
"    # This would be a bad random number generator!\n"
"    print(\"Hi\")\n"
"    yield 1\n"
"    print(\"Hello\")\n"
"    yield 7\n"
"    print(\"Howdy\")\n"
"    yield 4\n"
"    ..."
msgstr ""
"def get_random_number():\n"
"    # This would be a bad random number generator!\n"
"    print(\"Hi\")\n"
"    yield 1\n"
"    print(\"Hello\")\n"
"    yield 7\n"
"    print(\"Howdy\")\n"
"    yield 4\n"
"    ..."

msgid ""
"Similar to a coroutine function, calling a generator function does not run "
"it. Instead, it creates a generator object::"
msgstr ""
"I likhet med en coroutine-funktion körs inte en generatorfunktion när den "
"anropas. Istället skapas ett generatorobjekt::"

msgid ""
">>> get_random_number()\n"
"<generator object get_random_number at 0x1048671c0>"
msgstr ""
">>> get_random_number()\n"
"<generator object get_random_number at 0x1048671c0>"

msgid ""
"You can proceed to the next ``yield`` of a generator by using the built-in "
"function :func:`next`. In other words, the generator runs, then pauses. For "
"example::"
msgstr ""
"Du kan gå vidare till nästa ``yield`` i en generator genom att använda den "
"inbyggda funktionen :func:`next`. Med andra ord, generatorn körs och pausas "
"sedan. Till exempel::"

msgid ""
">>> generator = get_random_number()\n"
">>> next(generator)\n"
"Hi\n"
"1\n"
">>> next(generator)\n"
"Hello\n"
"7"
msgstr ""
">>> generator = get_random_number()\n"
">>> next(generator)\n"
"Hej\n"
"1\n"
">>> next(generator)\n"
"Hallå\n"
"7"

msgid "Tasks"
msgstr "Tasks"

msgid ""
"Roughly speaking, :ref:`tasks <asyncio-task-obj>` are coroutines (not "
"coroutine functions) tied to an event loop. A task also maintains a list of "
"callback functions whose importance will become clear in a moment when we "
"discuss :keyword:`await`. The recommended way to create tasks is via :func:"
"`asyncio.create_task`."
msgstr ""
"Grovt sett är :ref:`tasks <asyncio-task-obj>` coroutines (inte coroutine-"
"funktioner) knutna till en händelseslinga. En task upprätthåller också en "
"lista över callback-funktioner vars betydelse kommer att framgå när vi "
"diskuterar :keyword:`await`. Det rekommenderade sättet att skapa uppgifter "
"är via :func:`asyncio.create_task`."

msgid ""
"Creating a task automatically schedules it for execution (by adding a "
"callback to run it in the event loop's to-do list, that is, collection of "
"jobs)."
msgstr ""
"När du skapar en uppgift schemaläggs den automatiskt för utförande (genom "
"att lägga till ett callback för att köra den i händelseslingans att göra-"
"lista, dvs. en samling jobb)."

msgid ""
"Since there's only one event loop (in each thread), :mod:`!asyncio` takes "
"care of associating the task with the event loop for you. As such, there's "
"no need to specify the event loop."
msgstr ""
"Eftersom det bara finns en händelseslinga (i varje tråd) tar :mod:`!asyncio` "
"hand om att associera uppgiften med händelseslingan åt dig. Därför finns det "
"inget behov av att specificera händelseslingan."

msgid ""
"coroutine = loudmouth_penguin(magic_number=5)\n"
"# This creates a Task object and schedules its execution via the event "
"loop.\n"
"task = asyncio.create_task(coroutine)"
msgstr ""
"coroutine = loudmouth_penguin(magic_number=5)\n"
"# This creates a Task object and schedules its execution via the event "
"loop.\n"
"task = asyncio.create_task(coroutine)"

msgid ""
"Earlier, we manually created the event loop and set it to run forever. In "
"practice, it's recommended to use (and common to see) :func:`asyncio.run`, "
"which takes care of managing the event loop and ensuring the provided "
"coroutine finishes before advancing. For example, many async programs follow "
"this setup::"
msgstr ""
"Tidigare skapade vi händelseslingan manuellt och ställde in den på att köras "
"för evigt. I praktiken är det rekommenderat att använda (och vanligt att "
"se) :func:`asyncio.run`, som tar hand om hanteringen av händelseslingan och "
"ser till att den medföljande coroutinen avslutas innan den går vidare. Till "
"exempel följer många asynkrona program den här inställningen::"

msgid ""
"import asyncio\n"
"\n"
"async def main():\n"
"    # Perform all sorts of wacky, wild asynchronous things...\n"
"    ...\n"
"\n"
"if __name__ == \"__main__\":\n"
"    asyncio.run(main())\n"
"    # The program will not reach the following print statement until the\n"
"    # coroutine main() finishes.\n"
"    print(\"coroutine main() is done!\")"
msgstr ""
"import asyncio\n"
"\n"
"async def main():\n"
"    # Perform all sorts of wacky, wild asynchronous things...\n"
"    ...\n"
"\n"
"if __name__ == \"__main__\":\n"
"    asyncio.run(main())\n"
"    # The program will not reach the following print statement until the\n"
"    # coroutine main() finishes.\n"
"    print(\"coroutine main() is done!\")"

msgid ""
"It's important to be aware that the task itself is not added to the event "
"loop, only a callback to the task is. This matters if the task object you "
"created is garbage collected before it's called by the event loop. For "
"example, consider this program:"
msgstr ""
"Det är viktigt att vara medveten om att själva uppgiften inte läggs till i "
"händelseslingan, utan endast en återuppringning till uppgiften. Detta har "
"betydelse om det uppgiftsobjekt du skapade samlas in innan det anropas av "
"händelseslingan. Tänk till exempel på det här programmet:"

msgid ""
"async def hello():\n"
"    print(\"hello!\")\n"
"\n"
"async def main():\n"
"    asyncio.create_task(hello())\n"
"    # Other asynchronous instructions which run for a while\n"
"    # and cede control to the event loop...\n"
"    ...\n"
"\n"
"asyncio.run(main())"
msgstr ""
"async def hello():\n"
"    print(\"hello!\")\n"
"\n"
"async def main():\n"
"    asyncio.create_task(hello())\n"
"    # Other asynchronous instructions which run for a while\n"
"    # and cede control to the event loop...\n"
"    ...\n"
"\n"
"asyncio.run(main())"

msgid ""
"Because there's no reference to the task object created on line 5, it "
"*might* be garbage collected before the event loop invokes it. Later "
"instructions in the coroutine ``main()`` hand control back to the event loop "
"so it can invoke other jobs. When the event loop eventually tries to run the "
"task, it might fail and discover the task object does not exist! This can "
"also happen even if a coroutine keeps a reference to a task but completes "
"before that task finishes. When the coroutine exits, local variables go out "
"of scope and may be subject to garbage collection. In practice, ``asyncio`` "
"and Python's garbage collector work pretty hard to ensure this sort of thing "
"doesn't happen. But that's no reason to be reckless!"
msgstr ""
"Eftersom det inte finns någon referens till det uppgiftsobjekt som skapades "
"på rad 5, kan det *möjligen* rensas bort innan händelseslingan anropar det. "
"Senare instruktioner i korutinen ``main()`` återlämnar kontrollen till "
"händelseslingan så att den kan anropa andra jobb. När händelseslingan så "
"småningom försöker köra uppgiften kan det misslyckas och upptäcka att "
"uppgiftsobjektet inte finns! Detta kan också hända även om en korutin "
"behåller en referens till en uppgift men slutförs innan uppgiften är klar. "
"När korutinen avslutas går lokala variabler ut ur scope och kan bli föremål "
"för skräpinsamling. I praktiken arbetar ``asyncio`` och Pythons "
"skräpinsamlare hårt för att se till att sådant inte händer. Men det är ingen "
"anledning att vara vårdslös!"

msgid "await"
msgstr "await"

msgid ""
":keyword:`await` is a Python keyword that's commonly used in one of two "
"different ways::"
msgstr ""
":keyword:`await` är ett nyckelord i Python som vanligtvis används på två "
"olika sätt::"

msgid ""
"await task\n"
"await coroutine"
msgstr ""
"await task\n"
"await coroutine"

msgid ""
"In a crucial way, the behavior of ``await`` depends on the type of object "
"being awaited."
msgstr ""
"På ett avgörande sätt beror beteendet hos ``await`` på vilken typ av objekt "
"som väntas."

msgid ""
"Awaiting a task will cede control from the current task or coroutine to the "
"event loop. In the process of relinquishing control, a few important things "
"happen. We'll use the following code example to illustrate::"
msgstr ""
"Att invänta en uppgift innebär att kontrollen överförs från den aktuella "
"uppgiften eller coroutinen till händelseslingan. I samband med att "
"kontrollen överlåts händer några viktiga saker. Vi kommer att använda "
"följande kodexempel för att illustrera::"

msgid ""
"async def plant_a_tree():\n"
"    dig_the_hole_task = asyncio.create_task(dig_the_hole())\n"
"    await dig_the_hole_task\n"
"\n"
"    # Other instructions associated with planting a tree.\n"
"    ..."
msgstr ""
"async def plant_a_tree():\n"
"    dig_the_hole_task = asyncio.create_task(dig_the_hole())\n"
"    await dig_the_hole_task\n"
"\n"
"    # Other instructions associated with planting a tree.\n"
"    ..."

msgid ""
"In this example, imagine the event loop has passed control to the start of "
"the coroutine ``plant_a_tree()``. As seen above, the coroutine creates a "
"task and then awaits it. The ``await dig_the_hole_task`` instruction adds a "
"callback (which will resume ``plant_a_tree()``) to the ``dig_the_hole_task`` "
"object's list of callbacks. And then, the instruction cedes control to the "
"event loop. Some time later, the event loop will pass control to "
"``dig_the_hole_task`` and the task will finish whatever it needs to do. Once "
"the task finishes, it will add its various callbacks to the event loop, in "
"this case, a call to resume ``plant_a_tree()``."
msgstr ""
"I det här exemplet föreställer vi oss att händelseslingan har överfört "
"kontrollen till starten av coroutinen ``plant_a_tree()``. Som vi såg ovan "
"skapar coroutinen en uppgift och väntar sedan på den. Instruktionen ``await "
"dig_the_hole_task`` lägger till en återuppringning (som kommer att återuppta "
"``plant_a_tree()``) till objektet ``dig_the_hole_task`` lista över "
"återuppringningar. Och sedan lämnar instruktionen över kontrollen till "
"händelseslingan. En tid senare kommer händelseslingan att överföra "
"kontrollen till ``dig_the_hole_task`` och uppgiften kommer att avsluta vad "
"den behöver göra. När uppgiften är klar kommer den att lägga till sina olika "
"återuppringningar till händelseslingan, i det här fallet ett anrop för att "
"återuppta ``plant_a_tree()``."

msgid ""
"Generally speaking, when the awaited task finishes (``dig_the_hole_task``), "
"the original task or coroutine (``plant_a_tree()``) is added back to the "
"event loops to-do list to be resumed."
msgstr ""
"Generellt sett gäller att när den väntade uppgiften är klar "
"(``gräva_hålet_uppgiften``) läggs den ursprungliga uppgiften eller "
"coroutinen (``plantera_ett_träd()``) tillbaka till händelseslingans att-göra-"
"lista för att återupptas."

msgid ""
"This is a basic, yet reliable mental model. In practice, the control "
"handoffs are slightly more complex, but not by much. In part 2, we'll walk "
"through the details that make this possible."
msgstr ""
"Detta är en grundläggande men ändå tillförlitlig mental modell. I praktiken "
"är kontrollöverlämningarna något mer komplexa, men inte mycket. I del 2 går "
"vi igenom de detaljer som gör detta möjligt."

msgid ""
"**Unlike tasks, awaiting a coroutine does not hand control back to the event "
"loop!** Wrapping a coroutine in a task first, then awaiting that would cede "
"control. The behavior of ``await coroutine`` is effectively the same as "
"invoking a regular, synchronous Python function. Consider this program::"
msgstr ""
"**Till skillnad från uppgifter ger inte väntan på en coroutine tillbaka "
"kontrollen till händelseslingan!** Att först paketera in en coroutine i en "
"uppgift och sedan vänta på den skulle innebära att kontrollen övergår. "
"Beteendet för ``await coroutine`` är i praktiken detsamma som att anropa en "
"vanlig, synkron Python-funktion. Tänk på detta program::"

msgid ""
"import asyncio\n"
"\n"
"async def coro_a():\n"
"   print(\"I am coro_a(). Hi!\")\n"
"\n"
"async def coro_b():\n"
"   print(\"I am coro_b(). I sure hope no one hogs the event loop...\")\n"
"\n"
"async def main():\n"
"   task_b = asyncio.create_task(coro_b())\n"
"   num_repeats = 3\n"
"   for _ in range(num_repeats):\n"
"      await coro_a()\n"
"   await task_b\n"
"\n"
"asyncio.run(main())"
msgstr ""
"import asyncio\n"
"\n"
"async def coro_a():\n"
"   print(\"I am coro_a(). Hi!\")\n"
"\n"
"async def coro_b():\n"
"   print(\"I am coro_b(). I sure hope no one hogs the event loop...\")\n"
"\n"
"async def main():\n"
"   task_b = asyncio.create_task(coro_b())\n"
"   num_repeats = 3\n"
"   for _ in range(num_repeats):\n"
"      await coro_a()\n"
"   await task_b\n"
"\n"
"asyncio.run(main())"

msgid ""
"The first statement in the coroutine ``main()`` creates ``task_b`` and "
"schedules it for execution via the event loop. Then, ``coro_a()`` is "
"repeatedly awaited. Control never cedes to the event loop which is why we "
"see the output of all three ``coro_a()`` invocations before ``coro_b()``'s "
"output:"
msgstr ""
"Den första satsen i coroutinen ``main()`` skapar ``task_b`` och schemalägger "
"den för utförande via händelseslingan. Sedan inväntas ``coro_a()`` upprepade "
"gånger. Kontrollen överförs aldrig till händelseslingan, vilket är "
"anledningen till att vi ser utdata från alla tre ``coro_a()``-uppmaningarna "
"före ``coro_b()``:s utdata:"

msgid ""
"I am coro_a(). Hi!\n"
"I am coro_a(). Hi!\n"
"I am coro_a(). Hi!\n"
"I am coro_b(). I sure hope no one hogs the event loop..."
msgstr ""
"I am coro_a(). Hi!\n"
"I am coro_a(). Hi!\n"
"I am coro_a(). Hi!\n"
"I am coro_b(). I sure hope no one hogs the event loop..."

msgid ""
"If we change ``await coro_a()`` to ``await asyncio.create_task(coro_a())``, "
"the behavior changes. The coroutine ``main()`` cedes control to the event "
"loop with that statement. The event loop then proceeds through its backlog "
"of work, calling ``task_b`` and then the task which wraps ``coro_a()`` "
"before resuming the coroutine ``main()``."
msgstr ""
"Om vi ändrar ``await coro_a()`` till ``await asyncio.create_task(coro_a())`` "
"ändras beteendet. Coroutinen ``main()`` överlämnar kontrollen till "
"händelseslingan med detta uttalande. Händelseslingan fortsätter sedan genom "
"sitt eftersläpande arbete, anropar ``task_b`` och sedan den uppgift som "
"omsluter ``coro_a()`` innan den återupptar coroutinen ``main()``."

msgid ""
"I am coro_b(). I sure hope no one hogs the event loop...\n"
"I am coro_a(). Hi!\n"
"I am coro_a(). Hi!\n"
"I am coro_a(). Hi!"
msgstr ""
"I am coro_b(). I sure hope no one hogs the event loop...\n"
"I am coro_a(). Hi!\n"
"I am coro_a(). Hi!\n"
"I am coro_a(). Hi!"

msgid ""
"This behavior of ``await coroutine`` can trip a lot of people up! That "
"example highlights how using only ``await coroutine`` could unintentionally "
"hog control from other tasks and effectively stall the event loop. :func:"
"`asyncio.run` can help you detect such occurences via the ``debug=True`` "
"flag which accordingly enables :ref:`debug mode <asyncio-debug-mode>`. Among "
"other things, it will log any coroutines that monopolize execution for 100ms "
"or longer."
msgstr ""
"Detta beteende hos ``await coroutine`` kan göra många människor förvirrade! "
"Det exemplet belyser hur användning av endast ``await coroutine`` "
"oavsiktligt kan ta kontroll från andra uppgifter och effektivt stoppa "
"händelseslingan. :func:`asyncio.run` kan hjälpa dig att upptäcka sådana "
"händelser via flaggan ``debug=True`` som följaktligen aktiverar :ref:`debug "
"mode <asyncio-debug-mode>`. Bland annat loggas alla coroutines som "
"monopoliserar exekveringen i 100 ms eller längre."

msgid ""
"The design intentionally trades off some conceptual clarity around usage of "
"``await`` for improved performance. Each time a task is awaited, control "
"needs to be passed all the way up the call stack to the event loop. That "
"might sound minor, but in a large program with many ``await``'s and a deep "
"callstack that overhead can add up to a meaningful performance drag."
msgstr ""
"Konstruktionen innebär att viss konceptuell klarhet kring användningen av "
"``await`` avsiktligt byts ut mot förbättrad prestanda. Varje gång en uppgift "
"väntar måste kontrollen skickas hela vägen upp i anropsstacken till "
"händelseslingan. Det kanske låter obetydligt, men i ett stort program med "
"många ``await`` och en djup anropsstack kan detta leda till en meningsfull "
"prestandaförlust."

msgid "A conceptual overview part 2: the nuts and bolts"
msgstr "En konceptuell översikt del 2: skruvar och muttrar"

msgid ""
"Part 2 goes into detail on the mechanisms :mod:`!asyncio` uses to manage "
"control flow. This is where the magic happens. You'll come away from this "
"section knowing what ``await`` does behind the scenes and how to make your "
"own asynchronous operators."
msgstr ""
"Del 2 går in i detalj på de mekanismer som :mod:`!asyncio` använder för att "
"hantera kontrollflödet. Det är här det magiska händer. Du kommer från detta "
"avsnitt att veta vad ``await`` gör bakom kulisserna och hur du skapar dina "
"egna asynkrona operatörer."

msgid "The inner workings of coroutines"
msgstr "Det inre arbetet med coroutines"

msgid ":mod:`!asyncio` leverages four components to pass around control."
msgstr ""
":mod:`!asyncio` utnyttjar fyra komponenter för att skicka runt kontrollen."

msgid ""
":meth:`coroutine.send(arg) <generator.send>` is the method used to start or "
"resume a coroutine. If the coroutine was paused and is now being resumed, "
"the argument ``arg`` will be sent in as the return value of the ``yield`` "
"statement which originally paused it. If the coroutine is being used for the "
"first time (as opposed to being resumed) ``arg`` must be ``None``."
msgstr ""
":meth:`coroutine.send(arg) <generator.send>` är den metod som används för "
"att starta eller återuppta en coroutine. Om coroutinen pausades och nu "
"återupptas, kommer argumentet ``arg`` att skickas in som returvärdet för "
"``yield``\\ -satsen som ursprungligen pausade den. Om coroutinen används för "
"första gången (i motsats till att återupptas) måste ``arg`` vara ``None``."

msgid ""
"class Rock:\n"
"    def __await__(self):\n"
"        value_sent_in = yield 7\n"
"        print(f\"Rock.__await__ resuming with value: {value_sent_in}.\")\n"
"        return value_sent_in\n"
"\n"
"async def main():\n"
"    print(\"Beginning coroutine main().\")\n"
"    rock = Rock()\n"
"    print(\"Awaiting rock...\")\n"
"    value_from_rock = await rock\n"
"    print(f\"Coroutine received value: {value_from_rock} from rock.\")\n"
"    return 23\n"
"\n"
"coroutine = main()\n"
"intermediate_result = coroutine.send(None)\n"
"print(f\"Coroutine paused and returned intermediate value: "
"{intermediate_result}.\")\n"
"\n"
"print(f\"Resuming coroutine and sending in value: 42.\")\n"
"try:\n"
"    coroutine.send(42)\n"
"except StopIteration as e:\n"
"    returned_value = e.value\n"
"print(f\"Coroutine main() finished and provided value: {returned_value}.\")"
msgstr ""
"class Rock:\n"
"    def __await__(self):\n"
"        value_sent_in = yield 7\n"
"        print(f\"Rock.__await__ resuming with value: {value_sent_in}.\")\n"
"        return value_sent_in\n"
"\n"
"async def main():\n"
"    print(\"Beginning coroutine main().\")\n"
"    rock = Rock()\n"
"    print(\"Awaiting rock...\")\n"
"    value_from_rock = await rock\n"
"    print(f\"Coroutine received value: {value_from_rock} from rock.\")\n"
"    return 23\n"
"\n"
"coroutine = main()\n"
"intermediate_result = coroutine.send(None)\n"
"print(f\"Coroutine paused and returned intermediate value: "
"{intermediate_result}.\")\n"
"\n"
"print(f\"Resuming coroutine and sending in value: 42.\")\n"
"try:\n"
"    coroutine.send(42)\n"
"except StopIteration as e:\n"
"    returned_value = e.value\n"
"print(f\"Coroutine main() finished and provided value: {returned_value}.\")"

msgid ""
":ref:`yield <yieldexpr>`, like usual, pauses execution and returns control "
"to the caller. In the example above, the ``yield``, on line 3, is called by "
"``... = await rock`` on line 11. More broadly speaking, ``await`` calls the :"
"meth:`~object.__await__` method of the given object. ``await`` also does one "
"more very special thing: it propagates (or \"passes along\") any ``yield``\\ "
"s it receives up the call-chain. In this case, that's back to ``... = "
"coroutine.send(None)`` on line 16."
msgstr ""
":ref:`yield <yieldexpr>`, som vanligt, pausar exekveringen och återlämnar "
"kontrollen till den som anropar. I exemplet ovan anropas ``yield`` på rad 3 "
"av ``... = await rock`` på rad 11. Mer allmänt anropar ``await`` metoden :"
"meth:`~object.__await__` för det givna objektet. ``await`` gör också en "
"annan mycket speciell sak: den sprider (eller \"skickar vidare\") alla "
"``yield`` som den får upp i anropskedjan. I det här fallet är det tillbaka "
"till ``... = coroutine.send(None)`` på rad 16."

msgid ""
"The coroutine is resumed via the ``coroutine.send(42)`` call on line 21. The "
"coroutine picks back up from where it ``yield``\\ ed (or paused) on line 3 "
"and executes the remaining statements in its body. When a coroutine "
"finishes, it raises a :exc:`StopIteration` exception with the return value "
"attached in the :attr:`~StopIteration.value` attribute."
msgstr ""
"Coroutinen återupptas via anropet ``coroutine.send(42)`` på rad 21. "
"Coroutinen tar vid där den \"gav upp\" (eller pausade) på rad 3 och utför de "
"återstående satserna i dess kropp. När en coroutine är klar utlöser den ett :"
"exc:`StopIteration`-undantag med returvärdet i attributet :attr:"
"`~StopIteration.value`."

msgid "That snippet produces this output:"
msgstr "Det utdraget ger följande resultat:"

msgid ""
"Beginning coroutine main().\n"
"Awaiting rock...\n"
"Coroutine paused and returned intermediate value: 7.\n"
"Resuming coroutine and sending in value: 42.\n"
"Rock.__await__ resuming with value: 42.\n"
"Coroutine received value: 42 from rock.\n"
"Coroutine main() finished and provided value: 23."
msgstr ""
"Börjar coroutine main().\n"
"Väntar på rock...\n"
"Coroutine pausade och returnerade mellanvärde: 7.\n"
"Återupptar coroutine och skickar in värde: 42.\n"
"Rock.__await__ återupptas med värde: 42.\n"
"Coroutine mottog värde: 42 från rock.\n"
"Coroutine main() avslutades och gav värde: 23."

msgid ""
"It's worth pausing for a moment here and making sure you followed the "
"various ways that control flow and values were passed. A lot of important "
"ideas were covered and it's worth ensuring your understanding is firm."
msgstr ""
"Det är värt att stanna upp ett ögonblick här och se till att du följde de "
"olika sätten som kontrollflödet och värdena skickades. Många viktiga idéer "
"täcktes och det är värt att se till att din förståelse är fast."

msgid ""
"The only way to yield (or effectively cede control) from a coroutine is to "
"``await`` an object that ``yield``\\ s in its ``__await__`` method. That "
"might sound odd to you. You might be thinking:"
msgstr ""
"Det enda sättet att ge upp (eller effektivt överlåta kontrollen) från en "
"coroutine är att ``await`` ett objekt som ``yield`` s i dess ``__await__`` "
"metod. Det kanske låter konstigt för dig. Du kanske tänker:"

msgid ""
"1. What about a ``yield`` directly within the coroutine function? The "
"coroutine function becomes an :ref:`async generator function <asynchronous-"
"generator-functions>`, a different beast entirely."
msgstr ""
"1. Vad sägs om en ``yield`` direkt inom coroutine-funktionen? Coroutine-"
"funktionen blir en :ref:`async generatorfunktion <asynchronous-generator-"
"functions>`, en helt annan best."

msgid ""
"2. What about a :ref:`yield from <yieldexpr>` within the coroutine function "
"to a (plain) generator? That causes the error: ``SyntaxError: yield from not "
"allowed in a coroutine.`` This was intentionally designed for the sake of "
"simplicity -- mandating only one way of using coroutines. Initially "
"``yield`` was barred as well, but was re-accepted to allow for async "
"generators. Despite that, ``yield from`` and ``await`` effectively do the "
"same thing."
msgstr ""
"2. Hur är det med en :ref:`yield from <yieldexpr>` inom coroutine-funktionen "
"till en (vanlig) generator? Det orsakar felet: ``SyntaxError: yield from not "
"allowed in a coroutine.`` Detta var avsiktligt utformat för enkelhetens "
"skull - att bara tillåta ett sätt att använda coroutines. Ursprungligen var "
"``yield`` också förbjudet, men accepterades igen för att möjliggöra "
"asynkrona generatorer. Trots det gör ``yield from`` och ``await`` effektivt "
"samma sak."

msgid "Futures"
msgstr "Futures"

msgid ""
"A :ref:`future <asyncio-future-obj>` is an object meant to represent a "
"computation's status and result. The term is a nod to the idea of something "
"still to come or not yet happened, and the object is a way to keep an eye on "
"that something."
msgstr ""
"En :ref:`future <asyncio-future-obj>` är ett objekt som är avsett att "
"representera en beräknings status och resultat. Termen är en blinkning till "
"idén om något som fortfarande ska komma eller ännu inte har hänt, och "
"objektet är ett sätt att hålla ett öga på detta något."

msgid ""
"A future has a few important attributes. One is its state which can be "
"either \"pending\", \"cancelled\" or \"done\". Another is its result, which "
"is set when the state transitions to done. Unlike a coroutine, a future does "
"not represent the actual computation to be done; instead, it represents the "
"status and result of that computation, kind of like a status light (red, "
"yellow or green) or indicator."
msgstr ""
"En framtid har några viktiga attribut. Ett är dess tillstånd som kan vara "
"antingen \"pending\", \"cancelled\" eller \"done\". Ett annat är dess "
"resultat, som sätts när tillståndet övergår till done. Till skillnad från en "
"coroutine representerar en future inte den faktiska beräkningen som ska "
"göras, utan istället statusen och resultatet av den beräkningen, ungefär som "
"en statuslampa (röd, gul eller grön) eller indikator."

msgid ""
":class:`asyncio.Task` subclasses :class:`asyncio.Future` in order to gain "
"these various capabilities. The prior section said tasks store a list of "
"callbacks, which wasn't entirely accurate. It's actually the ``Future`` "
"class that implements this logic, which ``Task`` inherits."
msgstr ""
":class:`asyncio.Task` subklassar :class:`asyncio.Future` för att få dessa "
"olika möjligheter. I föregående avsnitt sades att uppgifter lagrar en lista "
"över återanrop, vilket inte var helt korrekt. Det är faktiskt klassen "
"``Future`` som implementerar den här logiken, som ``Task`` ärver."

msgid ""
"Futures may also be used directly (not via tasks). Tasks mark themselves as "
"done when their coroutine is complete. Futures are much more versatile and "
"will be marked as done when you say so. In this way, they're the flexible "
"interface for you to make your own conditions for waiting and resuming."
msgstr ""
"Futures kan också användas direkt (inte via tasks). Tasks markerar sig "
"själva som färdiga när deras coroutine är klar. Futures är mycket mer "
"mångsidiga och markeras som klara när du säger till. På så sätt är de ett "
"flexibelt gränssnitt där du kan skapa dina egna villkor för väntan och "
"återupptagning."

msgid "A homemade asyncio.sleep"
msgstr "En hemmagjord asyncio.sleep"

msgid ""
"We'll go through an example of how you could leverage a future to create "
"your own variant of asynchronous sleep (``async_sleep``) which mimics :func:"
"`asyncio.sleep`."
msgstr ""
"Vi ska gå igenom ett exempel på hur du kan utnyttja en framtid för att skapa "
"din egen variant av asynkron sömn (``async_sleep``) som efterliknar :func:"
"`asyncio.sleep`."

msgid ""
"This snippet registers a few tasks with the event loop and then awaits a "
"coroutine wrapped in a task: ``async_sleep(3)``. We want that task to finish "
"only after three seconds have elapsed, but without preventing other tasks "
"from running."
msgstr ""
"Detta utdrag registrerar några uppgifter med händelseslingan och väntar "
"sedan på en coroutine som är insvept i en uppgift: ``async_sleep(3)``. Vi "
"vill att den uppgiften ska avslutas först efter att tre sekunder har gått, "
"men utan att hindra andra uppgifter från att köras."

msgid ""
"async def other_work():\n"
"    print(\"I like work. Work work.\")\n"
"\n"
"async def main():\n"
"    # Add a few other tasks to the event loop, so there's something\n"
"    # to do while asynchronously sleeping.\n"
"    work_tasks = [\n"
"        asyncio.create_task(other_work()),\n"
"        asyncio.create_task(other_work()),\n"
"        asyncio.create_task(other_work())\n"
"    ]\n"
"    print(\n"
"        \"Beginning asynchronous sleep at time: \"\n"
"        f\"{datetime.datetime.now().strftime(\"%H:%M:%S\")}.\"\n"
"    )\n"
"    await asyncio.create_task(async_sleep(3))\n"
"    print(\n"
"        \"Done asynchronous sleep at time: \"\n"
"        f\"{datetime.datetime.now().strftime(\"%H:%M:%S\")}.\"\n"
"    )\n"
"    # asyncio.gather effectively awaits each task in the collection.\n"
"    await asyncio.gather(*work_tasks)"
msgstr ""
"async def other_work():\n"
"    print(\"I like work. Work work.\")\n"
"\n"
"async def main():\n"
"    # Add a few other tasks to the event loop, so there's something\n"
"    # to do while asynchronously sleeping.\n"
"    work_tasks = [\n"
"        asyncio.create_task(other_work()),\n"
"        asyncio.create_task(other_work()),\n"
"        asyncio.create_task(other_work())\n"
"    ]\n"
"    print(\n"
"        \"Beginning asynchronous sleep at time: \"\n"
"        f\"{datetime.datetime.now().strftime(\"%H:%M:%S\")}.\"\n"
"    )\n"
"    await asyncio.create_task(async_sleep(3))\n"
"    print(\n"
"        \"Done asynchronous sleep at time: \"\n"
"        f\"{datetime.datetime.now().strftime(\"%H:%M:%S\")}.\"\n"
"    )\n"
"    # asyncio.gather effectively awaits each task in the collection.\n"
"    await asyncio.gather(*work_tasks)"

msgid ""
"Below, we use a future to enable custom control over when that task will be "
"marked as done. If :meth:`future.set_result() <asyncio.Future.set_result>` "
"(the method responsible for marking that future as done) is never called, "
"then this task will never finish. We've also enlisted the help of another "
"task, which we'll see in a moment, that will monitor how much time has "
"elapsed and, accordingly, call ``future.set_result()``."
msgstr ""
"Nedan använder vi en future för att möjliggöra anpassad kontroll över när "
"den uppgiften ska markeras som klar. Om :meth:`future.set_result() <asyncio."
"Future.set_result>` (metoden som ansvarar för att markera den framtiden som "
"klar) aldrig anropas, kommer den här uppgiften aldrig att avslutas. Vi har "
"också tagit hjälp av en annan uppgift, som vi kommer att se om en stund, som "
"kommer att övervaka hur mycket tid som har gått och följaktligen anropa "
"``future.set_result()``."

msgid ""
"async def async_sleep(seconds: float):\n"
"    future = asyncio.Future()\n"
"    time_to_wake = time.time() + seconds\n"
"    # Add the watcher-task to the event loop.\n"
"    watcher_task = asyncio.create_task(_sleep_watcher(future, "
"time_to_wake))\n"
"    # Block until the future is marked as done.\n"
"    await future"
msgstr ""
"async def async_sleep(seconds: float):\n"
"    future = asyncio.Future()\n"
"    time_to_wake = time.time() + seconds\n"
"    # Add the watcher-task to the event loop.\n"
"    watcher_task = asyncio.create_task(_sleep_watcher(future, "
"time_to_wake))\n"
"    # Block until the future is marked as done.\n"
"    await future"

msgid ""
"Below, we'll use a rather bare object, ``YieldToEventLoop()``, to ``yield`` "
"from ``__await__`` in order to cede control to the event loop. This is "
"effectively the same as calling ``asyncio.sleep(0)``, but this approach "
"offers more clarity, not to mention it's somewhat cheating to use ``asyncio."
"sleep`` when showcasing how to implement it!"
msgstr ""
"Nedan kommer vi att använda ett ganska naket objekt, ``YieldToEventLoop()``, "
"för att ``yield`` från ``__await__`` för att överlåta kontrollen till "
"händelseslingan. Detta är effektivt detsamma som att ringa ``asyncio."
"sleep(0)``, men detta tillvägagångssätt ger mer tydlighet, för att inte tala "
"om att det är något fusk att använda ``asyncio.sleep`` när man visar hur man "
"implementerar det!"

msgid ""
"As usual, the event loop cycles through its tasks, giving them control and "
"receiving control back when they pause or finish. The ``watcher_task``, "
"which runs the coroutine ``_sleep_watcher(...)``, will be invoked once per "
"full cycle of the event loop. On each resumption, it'll check the time and "
"if not enough has elapsed, then it'll pause once again and hand control back "
"to the event loop. Eventually, enough time will have elapsed, and "
"``_sleep_watcher(...)`` will mark the future as done, and then itself finish "
"too by breaking out of the infinite ``while`` loop. Given this helper task "
"is only invoked once per cycle of the event loop, you'd be correct to note "
"that this asynchronous sleep will sleep *at least* three seconds, rather "
"than exactly three seconds. Note this is also of true of ``asyncio.sleep``."
msgstr ""
"Som vanligt cyklar händelseslingan genom sina uppgifter, ger dem kontroll "
"och får tillbaka kontrollen när de pausar eller avslutas. Uppgiften "
"``watcher_task``, som kör coroutinen ``_sleep_watcher(...)``, kommer att "
"anropas en gång per hel cykel av händelseslingan. Vid varje återupptagande "
"kommer den att kontrollera tiden och om inte tillräckligt mycket tid har "
"gått, kommer den att pausa igen och lämna tillbaka kontrollen till "
"händelseslingan. Så småningom kommer tillräckligt med tid att ha gått och "
"``_sleep_watcher(...)`` kommer att markera framtiden som klar och sedan "
"själv också avsluta genom att bryta sig ur den oändliga ``while``-slingan. "
"Med tanke på att denna hjälpuppgift bara anropas en gång per cykel av "
"händelseslingan, skulle du ha rätt att notera att denna asynkrona sömn "
"kommer att sova *minst* tre sekunder, snarare än exakt tre sekunder. "
"Observera att detta också gäller för ``asyncio.sleep``."

msgid ""
"class YieldToEventLoop:\n"
"    def __await__(self):\n"
"        yield\n"
"\n"
"async def _sleep_watcher(future, time_to_wake):\n"
"    while True:\n"
"        if time.time() >= time_to_wake:\n"
"            # This marks the future as done.\n"
"            future.set_result(None)\n"
"            break\n"
"        else:\n"
"            await YieldToEventLoop()"
msgstr ""
"class YieldToEventLoop:\n"
"    def __await__(self):\n"
"        yield\n"
"\n"
"async def _sleep_watcher(future, time_to_wake):\n"
"    while True:\n"
"        if time.time() >= time_to_wake:\n"
"            # This marks the future as done.\n"
"            future.set_result(None)\n"
"            break\n"
"        else:\n"
"            await YieldToEventLoop()"

msgid "Here is the full program's output:"
msgstr "Här är programmets fullständiga utdata:"

msgid ""
"$ python custom-async-sleep.py\n"
"Beginning asynchronous sleep at time: 14:52:22.\n"
"I like work. Work work.\n"
"I like work. Work work.\n"
"I like work. Work work.\n"
"Done asynchronous sleep at time: 14:52:25."
msgstr ""
"$ python custom-async-sleep.py\n"
"Beginning asynchronous sleep at time: 14:52:22.\n"
"I like work. Work work.\n"
"I like work. Work work.\n"
"I like work. Work work.\n"
"Done asynchronous sleep at time: 14:52:25."

msgid ""
"You might feel this implementation of asynchronous sleep was unnecessarily "
"convoluted. And, well, it was. The example was meant to showcase the "
"versatility of futures with a simple example that could be mimicked for more "
"complex needs. For reference, you could implement it without futures, like "
"so::"
msgstr ""
"Du kanske tycker att denna implementering av asynkron sömn var onödigt "
"komplicerad. Och det var den också. Exemplet var avsett att visa "
"mångsidigheten hos futures med ett enkelt exempel som kan efterliknas för "
"mer komplexa behov. Som referens kan du implementera det utan futures, så "
"här::"

msgid ""
"async def simpler_async_sleep(seconds):\n"
"    time_to_wake = time.time() + seconds\n"
"    while True:\n"
"        if time.time() >= time_to_wake:\n"
"            return\n"
"        else:\n"
"            await YieldToEventLoop()"
msgstr ""
"async def simpler_async_sleep(seconds):\n"
"    time_to_wake = time.time() + seconds\n"
"    while True:\n"
"        if time.time() >= time_to_wake:\n"
"            return\n"
"        else:\n"
"            await YieldToEventLoop()"

msgid ""
"But, that's all for now. Hopefully you're ready to more confidently dive "
"into some async programming or check out advanced topics in the :mod:`rest "
"of the documentation <asyncio>`."
msgstr ""
"Men det är allt för nu. Förhoppningsvis är du redo att med större "
"självförtroende dyka in i asynkron programmering eller kolla in avancerade "
"ämnen i :mod:`resten av dokumentationen <asyncio>`."
